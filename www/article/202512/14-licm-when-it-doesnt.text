When LICM fails us
Date: 2025-12-14 06:00:00 America/Chicago
Status: Public
Summary: When aliasing can prevent loop-invariant code motion
Label: Coding, AoCO2025

<p class="ai-disclaimer">Written by me, proof-read by an LLM.
<br/>Details at end.</p>[Yesterday's LICM post](/202512/13-licking-licm) ended with the compiler pulling invariants like `size()` and `get_range` out of our loop - clean assembly, great performance. Job done, right?

Not quite. Let's see how that optimisation can disappear.

Let's say you had a `const char *`[^cpp], and wanted to write a function to return if there was an exclamation mark or not:

[^cpp]: Think of this as more a C-style implementation: in C++ we'd probably use a `string_view` here which avoids the specific issue we're about to run in to. And of course `strchr` and friends are more optimal, but...bear with me!

<iframe width="100%" height="480px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,labels,commentOnly,directives,demangle,intel,libraryCode',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'%23include+%3Ccstring%3E%0A%0Abool+has_exclamation_mark(const+char+%2Astring)+%7B%0A++for+(std::size_t+index+%3D+0%3B%0A+++++++index+%3C+std::strlen(string)%3B%0A+++++++%2B%2Bindex)%0A++%7B%0A++++if+(string%5Bindex%5D+%3D%3D+!'!!!')+%7B%0A++++++return+true%3B%0A++++%7D%0A++%7D%0A++return+false%3B%0A%7D'"></iframe>

Here we're relying on loop-invariant code motion (LICM) to move the `strlen` out of the loop, called once before we loop, and then the loop is:

```asm
.L4:
  add rdi, 1                ; ++index
  cmp BYTE PTR [rdi-1], 33  ; is string[index-1] a '!' ?
  je .L5                    ; if so, jump to "return true"
.L2:
  cmp rdi, rax              ; else...are we at the end?
  jne .L4                   ; loop if not
```

All pretty good. We'll learn in later posts[^vector] that we can improve on this simple loop, but for now this seems ok.

Now let's assume we were curious how many characters in total we were comparing across our entire program, and add some basic instrumentation[^ig]:

[^vector]: Specifically, either by using `strchr` or other settings, we can get the compiler's help to vectorize this. We'll talk more of that later.

[^ig]: We're going to ignore any threading issues here.

<iframe width="100%" height="610px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,labels,commentOnly,directives,demangle,intel,libraryCode',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'%23include+%3Ccstring%3E%0A%0Astd::size_t+num_compares%7B%7D%3B%0A%0Abool+has_exclamation_mark(const+char+%2Astring)+%7B%0A++for+(std::size_t+index+%3D+0%3B%0A+++++++index+%3C+std::strlen(string)%3B%0A+++++++%2B%2Bindex)%0A++%7B%0A++++%2B%2Bnum_compares%3B%0A++++if+(string%5Bindex%5D+%3D%3D+!'!!!')+%7B%0A++++++return+true%3B%0A++++%7D%0A++%7D%0A++return+false%3B%0A%7D'"></iframe>

We might reasonably expect a single increment to be added to our loop. But if we take a closer look:

```asm
.L4:
  add QWORD PTR num_compares[rip], 1; ++num_compares;
  cmp BYTE PTR [rbp+0+rbx], 33      ; is char a '!' ?
  je .L5                            ; if so, jump to "return true"
  add rbx, 1                        ; ++index
.L2:
  mov rdi, rbp                      ; er...
  call strlen                       ; what the heck? strlen?
  cmp rbx, rax                      ; oh no! what happened?
  jb .L4                            ; loop if index != strlen(...)
```

Suddenly we've lost our lovely LICM! By simply incrementing a global variable[^clang], we lost the ability to call `strlen` and keep the result. Why is this?

[^clang]: Making the variable `static` helps for clang, but not gcc. Clang sees that we don't use the variable and gets rid of it, but if we were to use it elsewhere it's possible it wouldn't be able to do this optimisation.

It comes down to aliasing: the compiler can't prove that the string we're getting the length of doesn't share memory with the `num_compares` variable! Every time we modify `num_compares` the compiler has to assume that _maybe_ the string changed as a result!

This seems pretty odd: why on earth would a string overlap with a `std::size_t`? Don't we have rules about this? Aren't we disallowed from doing such things - type punning is barred - at least in C++?

Unfortunately, `char*` has a **special** status in the standard[^aliasing]: it's allowed to alias with **anything**. That's why the compiler can't assume our string and `num_compares` occupy different memory! If we had any other type than `char *` then the compiler _could_ use LICM.

[^aliasing]: See [[basic.lval] paragraph 11](https://eel.is/c++draft/basic.lval#11) in the C++ draft standard, which lists `char`, `unsigned char`, and `std::byte` as exceptions to the strict aliasing rule.

At least, that's what I hoped. In practice neither GCC[^gcc-bug], clang[^clang-bug] nor MSVC were able to LICM the code I tried. I could easily be missing something here, so do let me know if you have any ideas.

[^gcc-bug]: I filed a [missed optimisation opportunity](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=122240) for GCC and the thought is the heuristic that handles inlining is perhaps making a poor choice. We'll talk about inlining later.

[^clang-bug]: Clang's optimiser had slightly different characteristics, and I [filed this issue](https://github.com/llvm/llvm-project/issues/163097) to track.

Today's post seems a bit of a downer: the compiler wasn't able to do an optimisation I had otherwise hoped it might. Tomorrow we'll look at some other examples where the compiler struggles with aliasing, and we'll see how to help it out.


_See [the video](https://youtu.be/OwFNblEEAXo) that accompanies this post._

---

_This post is day 14 of [Advent of Compiler Optimisations 2025](/AoCO2025),
a 25-day series exploring how compilers transform our code._

_This post was written by a human ([Matt Godbolt](/MattGodbolt)) and reviewed and proof-read by LLMs and humans._

_Support Compiler Explorer on [Patreon](https://patreon.com/c/mattgodbolt)
or [GitHub](https://github.com/sponsors/compiler-explorer),
or by buying CE products in the [Compiler Explorer Shop](https://shop.compiler-explorer.com)_.
