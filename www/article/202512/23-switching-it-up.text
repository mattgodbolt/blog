Switching it up a bit
Date: 2025-12-23 06:00:00 America/Chicago
Status: Public
Summary: Taking a look at the various ways the compiler can optimise switch statements
Label: Coding, AoCO2025

<p class="ai-disclaimer">Written by me, proof-read by an LLM.
<br/>Details at end.</p>The standard wisdom is that switch statements compile to jump tables. And they do - when the compiler can't find something cleverer to do instead.

Let's start with a really simple example:

<iframe width="100%" height="220px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,directives,libraryCode,intel,labels,demangle,commentOnly',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'unsigned+decide(unsigned+x)+%7B%0A++switch+(x)+%7B%0A++++case+0:+return+100%3B%0A++++case+1:+return+200%3B%0A++++case+2:+return+300%3B%0A++++case+3:+return+400%3B%0A++++case+4:+return+500%3B%0A++%7D%0A++return+0%3B%0A%7D'"></iframe>

Here the compiler has spotted the relationship between `x` and the return value, and rewritten the code as: `if (x < 5) return (x+1) * 100; else return 0;` - pretty neat. No jump table, just maths!

If we mix up the code a bit so there's no obvious relationship between the input and the return value:

<iframe width="100%" height="330px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,directives,libraryCode,intel,labels,demangle,commentOnly',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'unsigned+decide(unsigned+x)+%7B%0A++switch+(x)+%7B%0A++++case+0:+return+500%3B%0A++++case+1:+return+200%3B%0A++++case+2:+return+800%3B%0A++++case+3:+return+400%3B%0A++++case+4:+return+900%3B%0A++%7D%0A++return+0%3B%0A%7D'"></iframe>

Still no jump table: Now the compiler has built a bespoke lookup table (`CSWTCH.1`) and then uses `x` to index into it (after checking it's in bounds).

For "dense" case statements, like the ones above, the compiler can be smart. But even with relatively sparse inputs, the compiler can work its magic. Consider this "is it whitespace?" routine[^isspc]:

<iframe width="100%" height="250px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,directives,libraryCode,intel,labels,demangle,commentOnly',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'bool+is_whitespace(char+x)+%7B%0A++switch+(x)+%7B%0A++++case+!'+!':+return+true%3B%0A++++case+!'%5Ct!':+return+true%3B%0A++++case+!'%5Cn!':+return+true%3B%0A++++case+!'%5Cr!':+return+true%3B%0A++++case+!'%5Cv!':+return+true%3B%0A++++default:+return+false%3B%0A++%7D%0A%7D'"></iframe>

[^isspc]: Of course you should use `isspace()`.

That _still_ avoids any kind of jump table; and in fact even avoids a branch:

```asm
is_whitespace(char):
  sub edi, 9            ; edi = x - 9 (`\t`)
  mov eax, 8388631      ; eax = 0b100000000000000000010111
  bt rax, rdi           ; test bit edi in the eax bitmask
  setc al               ; al = (bit was set) ? 1 : 0
  xor edx, edx          ; edx = 0
  cmp dil, 24           ; compare edi with 24
  cmovnb eax, edx       ; replace al with edx (0) if not below
  ret                   ; return
```

The compiler has built a bitmask where each bit says "should we consider this character to be whitespace". To fit the range of bits needed to cover all the whitespace characters, the compiler indexes into the bitmask with `(x - 9)`. The bit test instruction ([`bt`](https://www.felixcloutier.com/x86/bt)) will test any bit position, but our 32-bit bitmask only has meaningful data in positions 0-31. The compiler checks that `(x - 9) <= 24` to ensure we're within the valid range [^wrap] of the bitmask (covering tab at position 0 through space at position 23), and replaces the result with 0 for anything outside this range.

[^wrap]: The `bt` instruction uses the bit position modulo the operand size. In this particular case the compiler emits a `bt rax, rdi` so values of (x-9) greater than 64 would potentially map onto some of the set bits.

Just to see what else the compiler can generate, let's take a look at both a dense and sparse example that the compiler can't replace with a table (you'll need to scroll around in the Compiler Explorer panes to see more):

<iframe width="100%" height="400px" src="https://aoco.compiler-explorer.com/e?hideEditorToolbars=true#compiler:g152,filters:'trim,directives,libraryCode,intel,labels,demangle,commentOnly',options:'-O2+-Wall+-Wextra+-Wpedantic+-Wconversion+-Wsign-conversion+-Werror+-std%3Dc%2B%2B2c',source:'void+func0(),+func1(),+func2(),+func3(),+func4(),+func2511(),+func5284(),+func4865()%3B%0Avoid+do_a_thing_dense(unsigned+x)+%7B%0A++switch+(x)+%7B%0A++++case+0:+func0()%3B+break%3B%0A++++case+1:+func1()%3B+break%3B%0A++++case+2:+func2()%3B+break%3B%0A++++case+3:+func3()%3B+break%3B%0A++++case+4:+func4()%3B+break%3B%0A++%7D%0A%7D%0Avoid+do_a_thing_sparse(unsigned+x)+%7B%0A++switch+(x)+%7B%0A++++case+1:++++func1()%3B++++break%3B%0A++++case+4:++++func4()%3B++++break%3B%0A++++case+2511:+func2511()%3B+break%3B%0A++++case+4865:+func4865()%3B+break%3B%0A++++case+5284:+func5284()%3B+break%3B%0A++%7D%0A%7D'"></iframe>

For the dense case, the compiler does make a jump table, and indexes by `x` to jump to the right `func` routine[^fall]. For the sparse case, the compiler has to fall back to essentially a set of `if()` statements, comparing and branching. However, it's clever enough to compare a "mid-range" value first (`2511`), and if the `x` value is greater, jumps to code that only looks at the `5284` and `4865`. So it's essentially a binary serarch tree of comparisons.

[^fall]: If you comment out the `case 4`, at least for GCC, you'll see the compiler goes back to compare-and-branch.

Different compilers employ quite different tricks, so take some time to see what clang does for all the above examples.

Write clear switch statements; let the compiler decide whether that means multiplication, bitmasks, or jump tables. It's pretty darned good at it!


_See [the video](https://youtu.be/aSljdPafBAw) that accompanies this post._

---

_This post is day 23 of [Advent of Compiler Optimisations 2025](/AoCO2025),
a 25-day series exploring how compilers transform our code._

_This post was written by a human ([Matt Godbolt](/MattGodbolt)) and reviewed and proof-read by LLMs and humans._

_Support Compiler Explorer on [Patreon](https://patreon.com/c/mattgodbolt)
or [GitHub](https://github.com/sponsors/compiler-explorer),
or by buying CE products in the [Compiler Explorer Shop](https://shop.compiler-explorer.com)_.
